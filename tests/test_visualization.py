"""Visualization testing.

Notes
-----
Defines a classes that tests the functioning of the `visualization` module and its components.
"""
from __future__ import division, absolute_import


__all__ = ['TestDependences', 'TestCorrelations']


import sys
sys.path.append('/home/sohse/projects/PUBLICATION/GITssh/bcn')

import unittest
import numpy as np
from bcn.data import DataSimulated
from bcn.utils.visualization import visualize_dependences, visualize_correlations
from bcn.cost import Cost
from bcn.solvers import ConjugateGradientSolver
from bcn.linear_operators import LinearOperatorCustom
from bcn.bias import guess_func
from bcn.utils.testing import assert_consistency

    
class TestDependences(unittest.TestCase):
    """Tests to verify that the visualizations produced without errors for the blind recovery approach.

    Attributes
    ----------
    seed : int, default = 42
        Random seed of the whole test.
    shape : tuple of int, default = (30, 30)
        Shape of the output bias matrix in the form of (n_samples, n_features).
    rank : int, default = 2
        Rank of the low-rank decomposition.
    n_measurements: int, default = 1000
        Number of linear operators and measurements to be generated.
    data : Data object
        Generated by simulation.

    Note
    ----
    The visualizations are not checked for actual correctness, only their construction for errors.
    """  
    def setUp(self, seed=42):
        np.random.seed(seed)
        self.shape = None
        self.rank = 2
        self.n_measurements = 500
        self.data = None
    
    def test_dependences_true(self):
        self.shape = (50, 60)
        self.data = DataSimulated(self.shape, self.rank)
        self.data.estimate(true_stds={'sample': self.data.d['sample']['true_stds'], 'feature': self.data.d['feature']['true_stds']}, true_pairs={'sample': self.data.d['sample']['true_pairs'], 'feature': self.data.d['feature']['true_pairs']}, true_directions={'sample': self.data.d['sample']['true_directions'], 'feature': self.data.d['feature']['true_directions']})
        operator = LinearOperatorCustom(self.data, self.n_measurements).generate()
        A = operator['A']
        y = operator['y']
        cost = Cost(A, y)
        solver = ConjugateGradientSolver(cost.cost_func, guess_func, self.data, self.rank, 10, verbosity=0)
        self.data = solver.recover()
        visualize_dependences(self.data, file_name='../out/test_dependences_true')
        assert_consistency(self.data.d['sample']['estimated_bias'], 'ff18deff3410ab070999bd00a34242be')
        
    def test_dependences_estimated(self):
        self.shape = (50, 60)
        self.data = DataSimulated(self.shape, self.rank)
        self.data.estimate()
        operator = LinearOperatorCustom(self.data, self.n_measurements).generate()
        A = operator['A']
        y = operator['y']
        cost = Cost(A, y)
        solver = ConjugateGradientSolver(cost.cost_func, guess_func, self.data, self.rank, 10, verbosity=0)
        self.data = solver.recover()
        visualize_dependences(self.data, file_name='../out/test_dependences')
        assert_consistency(self.data.d['sample']['estimated_bias'], 'ff3be93e453254ed4d560da8c182f6c5')

                
class TestCorrelations(unittest.TestCase):
    """Tests to verify that the visualizations produced without errors for the blind recovery approach.

    Attributes
    ----------
    seed : int, default = 42
        Random seed of the whole test.
    shape : tuple of int, default = (30, 30)
        Shape of the output bias matrix in the form of (n_samples, n_features).
    rank : int, default = 2
        Rank of the low-rank decomposition.
    n_measurements: int, default = 1000
        Number of linear operators and measurements to be generated.
    data : Data object
        Generated by simulation.

    Note
    ----
    The visualizations are not checked for actual correctness, only their construction for errors.
    """
    def setUp(self, seed=42):
        np.random.seed(seed)
        self.shape = (30, 30)
        self.rank = 2
        self.data = DataSimulated(self.shape, self.rank)
    
    def test_correlations(self):
        visualize_correlations(self.data, file_name='../out/test_correlations')
        self.data.estimate(true_stds={'sample': self.data.d['sample']['true_stds'], 'feature': self.data.d['feature']['true_stds']}, true_pairs={'sample': self.data.d['sample']['true_pairs'], 'feature': self.data.d['feature']['true_pairs']}, true_directions={'sample': self.data.d['sample']['true_directions'], 'feature': self.data.d['feature']['true_directions']})
        assert_consistency(self.data.d['sample']['estimated_correlations'], '4b06c6d6b4dc1f1b3c4895241a19c492')

    
if __name__ == '__main__':
    unittest.main()






    